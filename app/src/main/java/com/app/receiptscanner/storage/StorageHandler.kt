package com.app.receiptscanner.storage

import android.content.Context
import android.util.Log
import androidx.security.crypto.EncryptedFile
import androidx.security.crypto.MasterKey
import com.app.receiptscanner.database.Receipt
import com.app.receiptscanner.parser.FieldTemplate
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject
import java.io.ByteArrayOutputStream
import java.io.File
import java.nio.charset.StandardCharsets


/**
 * A class encompassing all storage related actions for the application. All actions involved are
 * done through AndroidX Jetpack Security to ensure that the sensitive information stored cannot be
 * read by a third party.
 *
 * @see EncryptedFile
 * @see MasterKey
 */
@Suppress("BlockingMethodInNonBlockingContext")
class StorageHandler(private val applicationContext: Context) {
    /**
     * Accesses an encrypted file in internal storage
     *
     * @param storageDirectory the file path for the application's internal storage
     * @param filename the name of the file to be found
     * @param overwrite whether or not the file should be overwritten. Necessary when
     * writing to a file that already exists
     * @return an EncryptedFile which can be used to read from or write to
     * @see EncryptedFile
     */
    private fun getEncryptedFile(
        storageDirectory: String,
        filename: String,
        overwrite: Boolean = false
    ): EncryptedFile {
        // If the folder for receipts doesn't exist, it is created here.
        val directory = File(storageDirectory + RECEIPT_SUB_PATH)
        if (!directory.exists()) directory.mkdirs()

        // Gets the encryption key for the user's device
        val masterKey = MasterKey
            .Builder(applicationContext, MasterKey.DEFAULT_MASTER_KEY_ALIAS)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .build()

        val file = File(directory, filename)

        // This is necessary as appending to an encrypted file is impossible, so to add to it,
        // it needs to be completely overwritten
        if(overwrite && file.exists()) file.delete()

        return EncryptedFile.Builder(
            applicationContext,
            file,
            masterKey,
            EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB
        ).build()
    }

    /**
     * Fetches a given receipt from internal storage. This receipt will have no information on the
     * specifics for it's type as it has been standardized
     *
     * @param receipt the Receipt to be fetched from external storage
     * @param storageDirectory the file path for the application's internal storage
     * @return a NormalizedReceipt containing all the fields for the stored receipt
     */
    suspend fun readReceipt(receipt: Receipt, storageDirectory: String) =
        withContext(Dispatchers.IO) {
            val encryptedFile = getEncryptedFile(storageDirectory, "id-${receipt.id}")
            val byteArrayOutputStream = ByteArrayOutputStream()

            // Reads the receipt file byte by byte from the file's input stream into an output stream.
            // The input stream is automatically closed after the file has been read in it's entirety
            encryptedFile.openFileInput().use { fileStream ->
                var bytesRead = fileStream.read()
                while (bytesRead != -1) {
                    byteArrayOutputStream.write(bytesRead)
                    bytesRead = fileStream.read()
                }
            }
            val data = byteArrayOutputStream.toByteArray()
            val json = JSONObject(data.toString(StandardCharsets.UTF_8))
            val name: String = json[FIELD_NAME].toString()
            val type: Int = json[FIELD_TYPE].toString().toInt()
            val fields = FieldTemplate.getFieldsById(type)

            // Iterates through all of the fields of the JSON object that was generated by the file data
            // converting each json field into a Field object
            Log.e("fields", "$fields")
            json.keys().forEach {
                if (it != FIELD_NAME && it != FIELD_TYPE) {
                    val identifier = ArrayList(it.split(SEPARATOR))
                    val fieldData = ArrayList(json[it].toString().split(SEPARATOR))
                    fields.setField(identifier, fieldData)
                    Log.e("JSON", "$json")
                    Log.e("DATA", "$identifier - $fieldData")
                }
            }
            val r = NormalizedReceipt(
                receipt.id,
                name,
                receipt.dateCreated,
                receipt.photoPath,
                type,
                fields
            )
            Log.e("REGEX", r.toString())
            return@withContext r
        }

    /**
     * Stores a given receipt in internal storage. The normalized version of the receipt is first
     * converted to JSON before being encrypted and stored.
     *
     * @param receipt the Receipt to be fetched from external storage
     * @param normalizedReceipt a standardized version of the receipt to be stored
     * @param storageDirectory the file path for the application's internal storage
     */
    suspend fun storeReceipt(
        receipt: Receipt,
        normalizedReceipt: NormalizedReceipt,
        storageDirectory: String
    ) = withContext(Dispatchers.IO) {
        val encryptedFile =
            getEncryptedFile(storageDirectory, "id-${receipt.id}", true)
        val json = JSONObject()
        json.put(FIELD_NAME, normalizedReceipt.name)
        json.put(FIELD_TYPE, normalizedReceipt.type)

        // Iterates through the receipt object's fields, converting each one into a JSON object
        // field.
        normalizedReceipt.fields.forEach {
            val key = it.key.joinToString(SEPARATOR)
            val value = it.value.data.joinToString(SEPARATOR)
            Log.e("STORE", "$key - $value")
            json.put(key, value)
        }
        val data = json.toString().toByteArray()
        encryptedFile.openFileOutput().use {
            it.write(data)
        }
    }

    companion object {
        private const val SEPARATOR = ":"
        private const val FIELD_NAME = "Name"
        private const val FIELD_TYPE = "Type"
        private const val RECEIPT_SUB_PATH = "/receipts/"
    }
}